function logSumm = summarizeVirmenLog_widefield(fp,saveto)

% logSumm = summarizeVirmenLog_widefield(fp,protocol)
% analyzes behavioral data saved in virmen log structure and aligns with
% imaging frames
%
% INPUT
%   fp: cell array with full file paths (typically generated by fileCellArray.m)
%   saveto: path for saving
%
% OUTPUT
%   logSumm: data structure with overall performance indicators and trial
%            data
%
% LP jul 2016

%% where to save
if nargin < 2
  saveto = widefieldParams.serverpath_spock;
end

%% first check if log already exists
if iscell(fp); fp = fp{1}; end
if ispc; bksl  = strfind(fp.behav,'\'); else bksl  = strfind(fp.behav,'/'); end
thisname       = fp.behav(bksl(end)+1:end); % file name

fprintf('   analyzing %s\n',thisname)
[thismouse,thisdate,thisgen] = mouseAndDateFromFileName(thisname);
fn                           = formatFilePath(sprintf('%s%s/%s/behavLog.mat',saveto,thismouse,thisdate),false);

if ~isempty(dir(fn)) % try loading it first
  load(fn,'logSumm')
  runFlag = false;
else
  runFlag = true;
end

%% load or create folders if necessary
if ~runFlag
  return

else
  cd(saveto);    if isempty(dir(thismouse)); mkdir(thismouse); end
  cd(thismouse); if isempty(dir(thisdate));  mkdir(thisdate);  end
  cd(thisdate)

  tic
  fprintf('\t\t\treading virmen log...')
  
  % load files from server
  load(fp.behav,'log')
  load(fp.widefield,'recDur','ts','frameRate','cfg')
  if cfg.strobedLED
    nZ        = numel(ts);
    frameRate = frameRate/2; 
    strobeSeq = repmat(cfg.strobeSeq,[1 floor(nZ/numel(cfg.strobeSeq))]);
    excFrames = nZ - numel(strobeSeq);
    strobeSeq = [strobeSeq cfg.strobeSeq(1:excFrames)];
    ts        = ts(strobeSeq==1);
  end
  
  %% get general info first
  
  % file names
  logSumm.info.mouseID      = log.animal.name;
  logSumm.info.protocol     = log.animal.protocol;
  logSumm.info.startTime    = log.session.start;
  logSumm.info.endTime      = log.session.end;
  logSumm.info.fn           = fn;
  logSumm.info.date         = thisdate;
  logSumm.info.behavFn      = thisname; % original file name
  logSumm.info.widefieldFn  = fp.widefield;
  
  % maze labels
  mazeInfo = feval(logSumm.info.protocol);
  for ii = 1:length(log.block)
    if ~isempty(log.block(ii).trial)
      logSumm.info.mazes(ii) = log.block(ii).mazeID;
      try
        [~,logSumm.info.mazeLbl{ii}] = formatMazeName(mazeInfo(log.block(ii).mazeID));
      catch
        logSumm.info.mazeLbl{ii} = '';
      end
    end
  end
  logSumm.info.mainMazeID      = log.block(end).mainMazeID;
  
  % deduce genotype from mouse name
  logSumm.info.genotype = thisgen;
  
  % timing for sync
  logSumm.info.virmenDurSec    =   log.session.end(4)*3600+log.session.end(5)*60+log.session.end(6) ...
                                 - log.session.start(4)*3600+log.session.start(5)*60+log.session.start(6);
  logSumm.info.widefieldDurSec = recDur;
  logSumm.info.camFPS          = frameRate;
  
  %% start compiling trials (drop block structure)
  logSumm.keyFrameLabels       = {'cue';'mem';'arm';'rew'};
  logSumm.meanPerfBlock        = [];
  logSumm.timeaxis             = [];
  logSumm.camDataIn            = [];
  
   % trial info
  tc = 0; % overall counter to concatenate blocks
  for b = 1:numel(log.block) % main maze blocks
    
    % there is a bug that generates empty blocks
    if isempty(log.block(b).trial); continue; end
    
    for t = 1:numel(log.block(b).trial) % trials within block
      
      %% cam sync
      logSumm.startTime(tc+t) = log.block(b).trial(t).start;
      logSumm.camDataIn       = [logSumm.camDataIn; log.block(b).trial(t).camDataIn];
      logSumm.timeaxis        = [logSumm.timeaxis;  log.block(b).trial(t).start+log.block(b).trial(t).time];
      if tc+t == 1
        logSumm.camOnTime     = log.block(b).trial(t).time(log.block(b).trial(t).iCamOn) ...
                                + widefieldParams.camTrigLagFrame*(1/logSumm.info.camFPS);
      end
      
      %% for user-enforced trial ending fill with nan
      if (strcmpi(char(log.block(b).trial(t).choice),'nil')                      ...
          && log.block(b).trial(t).time(log.block(b).trial(t).iterations) < 60 ) ...
          || isempty(log.block(b).trial(t).excessTravel)
        logSumm = fillwithnan(logSumm,tc,t);
        continue
      end
      
      %% first trial in the block?
      if t == 1
        logSumm.firstTrialofBlock(tc+t) = true;
      else
        logSumm.firstTrialofBlock(tc+t) = false;
      end
      
      %% maze info
      logSumm.currMaze(tc+t) = uint8(log.block(b).mazeID);
      logSumm.lCue(tc+t)     = single(mazeInfo(logSumm.currMaze(tc+t)).lCue);
      logSumm.lMemory(tc+t)  = single(mazeInfo(logSumm.currMaze(tc+t)).lMemory);
      logSumm.lStart(tc+t)   = single(mazeInfo(logSumm.currMaze(tc+t)).lStart);
      
      %% left or right trial
      if strcmpi(char(log.block(b).trial(t).trialType),'L')
        logSumm.trialType(tc+t) = single(analysisParams.leftCode);
      else
        logSumm.trialType(tc+t) = single(analysisParams.rightCode);
      end
      
      if ~isempty(log.block(b).trial(t).trialID);
        logSumm.stimID(tc+t) = int64(log.block(b).trial(t).trialID);
      else
        logSumm.stimID(tc+t) = nan;
      end
      
     
      %% animal went left or right
      if strcmpi(char(log.block(b).trial(t).choice),'L')
        logSumm.choice(tc+t) = single(analysisParams.leftCode);
      elseif strcmpi(char(log.block(b).trial(t).choice),'R')
        logSumm.choice(tc+t) = single(analysisParams.rightCode);
      else
        logSumm.choice(tc+t) = single(analysisParams.nilCode);
      end
      
      %% position, displacement, speed, view angle
      logSumm.excessTravel(tc+t) = single(log.block(b).trial(t).excessTravel);
      logSumm.pos{tc+t}          = single(log.block(b).trial(t).position); % position in Maze, cell array; [x y angle]
      logSumm.pos{tc+t}(:,3)     = -rad2deg(logSumm.pos{tc+t}(:,3)); % convert view angle to deg
      logSumm.displ{tc+t}        = diff(logSumm.pos{tc+t}); % displacement in Maze, cell array; [x y angle]
      if log.block(b).trial(t).iCueEntry > 0
        stemXYdispl              = logSumm.displ{tc+t}(log.block(b).trial(t).iCueEntry:log.block(b).trial(t).iArmEntry-1,1:2); % total XY displacement in Maze stem
      else
        stemXYdispl              = 0;
      end
      logSumm.stemDispl(tc+t)    = sum(sqrt(sum(stemXYdispl.^2,2))); % total displacement in stem
      if ~strcmpi(char(logSumm.info.protocol),'noworld')
        logSumm.stemDisplNorm(tc+t)= sum(sqrt(sum(stemXYdispl.^2,2)))./...
          (mazeInfo(logSumm.currMaze(tc+t)).lCue+mazeInfo(logSumm.currMaze(tc+t)).lMemory); % total displacement in stem normalized by stem length
      else
        logSumm.stemDisplNorm(tc+t)= sum(sqrt(sum(stemXYdispl.^2,2)))./...
          (mazeInfo(1).lCue+mazeInfo(1).lMemory);
      end
      if log.block(b).trial(t).iCueEntry > 0
        if log.block(b).trial(t).iArmEntry > 0
          logSumm.speedStem(tc+t)    = logSumm.stemDispl(tc+t)/...
            (log.block(b).trial(t).time(log.block(b).trial(t).iArmEntry)-...
            log.block(b).trial(t).time(log.block(b).trial(t).iCueEntry)); % speed in maze stem
        else
          logSumm.speedStem(tc+t)    = logSumm.stemDispl(tc+t)/...
            (log.block(b).trial(t).time(length(log.block(b).trial(t).position))-...
            log.block(b).trial(t).time(log.block(b).trial(t).iCueEntry)); % speed in maze stem
        end
      else
        logSumm.speedStem(tc+t)    = single(nan);
      end
      
      %% generative probability, reward, raw sensor readout etc
      logSumm.trialProb{tc+t}   = single(log.block(b).trial(t).trialProb);
      logSumm.rewardScale(tc+t) = single(log.block(b).trial(t).rewardScale);
      logSumm.sensorDots{tc+t}  = single(log.block(b).trial(t).sensorDots);
      
      %% cue info (deal with the fact that when cues don't appear cue onset iter will be = 0)
      % (if this is the case both position and onset will be filled with NaN)
      logSumm.cueOrder{tc+t}            = single(log.block(b).trial(t).cueCombo); % boolean, [left cues; right cues]
      [logSumm.cuePos_R{tc+t},Rorder]   = sort(single(log.block(b).trial(t).cuePos{2}));
      [logSumm.cuePos_L{tc+t},Lorder]   = sort(single(log.block(b).trial(t).cuePos{1}));
      
      idxR                              = single(log.block(b).trial(t).cueOnset{2}(Rorder));
      logSumm.cueOnset_R{tc+t}          = single(nan(1,numel(idxR)));
      logSumm.cueOnset_R{tc+t}(idxR>0)  = log.block(b).trial(t).time(idxR(idxR>0));
      logSumm.cuePos_R{tc+t}(idxR<1)    = single(nan);
      
      idxL                              = single(log.block(b).trial(t).cueOnset{1}(Lorder));
      logSumm.cueOnset_L{tc+t}          = single(nan(1,numel(idxL)));
      logSumm.cueOnset_L{tc+t}(idxL>0)  = log.block(b).trial(t).time(idxL(idxL>0));
      logSumm.cuePos_L{tc+t}(idxL<1)    = single(nan);
      
      idxR                              = single(log.block(b).trial(t).cueOffset{2}(Rorder));
      logSumm.cueOffset_R{tc+t}         = single(nan(1,numel(idxR)));
      logSumm.cueOffset_R{tc+t}(idxR>0) = log.block(b).trial(t).time(idxR(idxR>0));
      
      idxL                              = single(log.block(b).trial(t).cueOffset{1}(Lorder));
      logSumm.cueOffset_L{tc+t}         = single(nan(1,numel(idxL)));
      logSumm.cueOffset_L{tc+t}(idxL>0) = log.block(b).trial(t).time(idxL(idxL>0));
      
      logSumm.nCues_R(tc+t)             = single(numel(log.block(b).trial(t).cuePos{2}));
      logSumm.nCues_L(tc+t)             = single(numel(log.block(b).trial(t).cuePos{1}));
      
      try
        logSumm.cueDur_R{tc+t}  = single(log.block(b).trial(t).time(log.block(b).trial(t).cueOffset{2}) - ...
          log.block(b).trial(t).time(log.block(b).trial(t).cueOnset{2}));
        logSumm.cueDur_L{tc+t}  = single(log.block(b).trial(t).time(log.block(b).trial(t).cueOffset{1}) - ...
          log.block(b).trial(t).time(log.block(b).trial(t).cueOnset{1}));
      catch
        logSumm.cueDur_R{tc+t}  = single(inf); logSumm.cueDur_L{tc+t}  = single(inf);
      end
      
      %% more timing info
      logSumm.time{tc+t}          = single(log.block(b).trial(t).time);
      % corresponds to logSumm.keyFrameLabels; [cue mem arm rew]
      logSumm.keyFrames{tc+t}     = single([log.block(b).trial(t).iCueEntry log.block(b).trial(t).iMemEntry ...
                                            log.block(b).trial(t).iArmEntry length(log.block(b).trial(t).position)]); 
      logSumm.trialDur(tc+t)      = logSumm.time{tc+t}(length(log.block(b).trial(t).position));
      if log.block(b).trial(t).iCueEntry > 0
        if log.block(b).trial(t).iMemEntry > 0
          logSumm.trialDurCue(tc+t)   = logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iCueEntry);
        else
          logSumm.trialDurCue(tc+t)   = logSumm.time{tc+t}(length(log.block(b).trial(t).position)) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iCueEntry);
        end
        if log.block(b).trial(t).iMemEntry > 0 && log.block(b).trial(t).iArmEntry > 0
          logSumm.trialDurMem(tc+t)   = logSumm.time{tc+t}(log.block(b).trial(t).iArmEntry) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry);
        elseif log.block(b).trial(t).iMemEntry > 0 && log.block(b).trial(t).iArmEntry <= 0
          logSumm.trialDurMem(tc+t)   = logSumm.time{tc+t}(length(log.block(b).trial(t).position)) - ...
            logSumm.time{tc+t}(log.block(b).trial(t).iMemEntry);
        else
          logSumm.trialDurMem(tc+t)   = single(nan);
        end
      else
        logSumm.trialDurCue(tc+t)   = single(nan);
        logSumm.trialDurMem(tc+t)   = single(nan);
      end
      logSumm.trialDurFull(tc+t)  = single(log.block(b).trial(t).duration);
      
      try
        fr(tc+t) = mean(diff(logSumm.time{tc+t}(logSumm.keyFrames{tc+t}(2):logSumm.keyFrames{tc+t}(4))));
      catch
        fr(tc+t) = single(nan);
      end
      
    end
    
    %% avg performance in block
    if ~isempty(t);
      % mean performance by block, all trials
      ttype = logSumm.trialType(end-t+1:end);
      ch    = logSumm.choice(end-t+1:end);
      
      % mean performance by block, ctrl trials
      perftemp                = sum(ttype == ch)/numel(ch);
      logSumm.meanPerfBlock   = [logSumm.meanPerfBlock ones(1,t)*perftemp];
      
      tc = tc + t; % udpate total number of trials
    end
  end
  
  %% deal with empty logs
  if ~isfield(logSumm,'choice'); logSumm = fillwithnan(logSumm,0,1); end
  if isempty(logSumm.meanPerfBlock); logSumm.meanPerfBlock = nan; end
  
  %% record more easy-access variables
  perftemp = sum(logSumm.trialType(logSumm.currMaze==max(logSumm.currMaze))   ...
                  == logSumm.choice(logSumm.currMaze==max(logSumm.currMaze))) ...
                 /sum(logSumm.currMaze==max(logSumm.currMaze));
  logSumm.meanPerfMainMaze = ones(1,numel(logSumm.trialType))*perftemp;
  
  % effective durations (given specific sue positions
  logSumm.nCues_RminusL = logSumm.nCues_R-logSumm.nCues_L;
  logSumm.nCues_total   = logSumm.nCues_R+logSumm.nCues_L;
  logSumm.ntrials       = single(numel(logSumm.trialType));
  logSumm.protocolID    = uint8(ones(1,logSumm.ntrials).*find(strcmpi(analysisParams.behavProtType,char(logSumm.info.protocol))==1));
  
  maxr = cellfun(@max,logSumm.cuePos_R,'UniformOutput',false);
  maxl = cellfun(@max,logSumm.cuePos_L,'UniformOutput',false);
  minr = cellfun(@min,logSumm.cuePos_R,'UniformOutput',false);
  minl = cellfun(@min,logSumm.cuePos_L,'UniformOutput',false);
  for iT = 1:numel(maxr)
    maxrl(iT) = max([maxr{iT} maxl{iT}]);
    minrl(iT) = min([minr{iT} minl{iT}]);
  end
  logSumm.effectiveCueDurCm  = maxrl - minrl;
  logSumm.effectiveMemDurCm  = logSumm.lMemory + (logSumm.lCue - maxrl);
  
  maxr = cellfun(@max,logSumm.cueOnset_R,'UniformOutput',false);
  maxl = cellfun(@max,logSumm.cueOnset_L,'UniformOutput',false);
  minr = cellfun(@min,logSumm.cueOnset_R,'UniformOutput',false);
  minl = cellfun(@min,logSumm.cueOnset_L,'UniformOutput',false);
  for iT = 1:numel(maxr)
    maxrl(iT) = max([maxr{iT} maxl{iT}]);
    minrl(iT) = min([minr{iT} minl{iT}]);
  end
  logSumm.effectiveCueDurSec = maxrl - minrl;
  logSumm.effectiveMemDurSec = logSumm.trialDurMem + (logSumm.trialDurCue - maxrl);  
  
  %% average frame rate during maze navigation (excludes ITI)
  try logSumm.frameRateVirmen = nanmean(fr(fr~=0)); catch; logSumm.frameRateVirmen = single(nan); end

  %% align with imaging
  fprintf('\n')
  logSumm = extractFrameTimeByTrials(logSumm,ts,cfg);
  logSumm = removeExtraTrials(logSumm); % sometimes imaging finishes before behavior
  
  fprintf('\n\t\tdone after %1.1f sec\n',toc)
  
  %% save
  save(fn,'logSumm')

end

end

%% fill with nan's in case of aborted trial
function logSumm = fillwithnan(logSumm,tc,t)
if t == 1; logSumm.firstTrialofBlock(tc+t) = true; else logSumm.firstTrialofBlock(tc+t) = false; end
logSumm.currMaze(tc+t)          = uint8(nan);
logSumm.lCue(tc+t)              = single(nan);
logSumm.lMemory(tc+t)           = single(nan);
logSumm.lStart(tc+t)            = single(nan);
logSumm.trialType(tc+t)         = single(nan);
logSumm.stimID(tc+t)            = int64(nan);
logSumm.choice(tc+t)            = single(nan);
logSumm.excessTravel(tc+t)      = single(nan);
logSumm.pos{tc+t}               = single([nan nan nan]);
logSumm.displ{tc+t}             = single([nan nan nan]);
logSumm.stemDispl(tc+t)         = single(nan);
logSumm.stemDisplNorm(tc+t)     = single(nan);
logSumm.speedStem(tc+t)         = single(nan);
logSumm.trialProb{tc+t}         = single(nan);
logSumm.rewardScale(tc+t)       = single(nan);
logSumm.sensorDots{tc+t}        = single([nan nan nan nan nan]);
logSumm.cueOrder{tc+t}          = single(nan);
logSumm.cuePos_R{tc+t}          = single(nan);
logSumm.cuePos_L{tc+t}          = single(nan);
logSumm.cueOnset_R{tc+t}        = single(nan);
logSumm.cueOnset_L{tc+t}        = single(nan);
logSumm.cueOffset_R{tc+t}       = single(nan);
logSumm.cueOffset_L{tc+t}       = single(nan);
logSumm.nCues_R(tc+t)           = single(nan);
logSumm.nCues_L(tc+t)           = single(nan);
logSumm.cueDur_R{tc+t}          = single(inf);
logSumm.cueDur_L{tc+t}          = single(inf);
logSumm.time{tc+t}              = single(nan);
logSumm.keyFrames{tc+t}         = single(nan);
logSumm.trialDur(tc+t)          = single(nan);
logSumm.trialDurCue(tc+t)       = single(nan);
logSumm.trialDurMem(tc+t)       = single(nan);
logSumm.trialDurFull(tc+t)      = single(nan);

end


%% delete trials without corresponding imaging
function logSumm = removeExtraTrials(logSumm)

minNfr  = round(1/logSumm.frameDtCam); % at least 1 sec of data
frameCt = cellfun(@(x)(numel(x)),logSumm.binned.camFrameID);
delidx  = frameCt < minNfr;

if sum(delidx) == 0; return; end

names = fieldnames(logSumm);
for ii = 1:numel(names)
  if numel(logSumm.names{ii}) == logSumm.ntrials
    logSumm.(names{ii})(delidx)=[];
  end
end

names = fieldnames(logSumm.binned);
for ii = 1:numel(names)
  if numel(logSumm.binned.names{ii}) == logSumm.ntrials
    logSumm.binned.(names{ii})(delidx)=[];
  end
end

logSumm.ntrials = logSumm.ntrials - numel(delidx);

end

